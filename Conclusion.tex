% % !TEX root = MasterThesis.tex

\chapter{Conclusion}\label{ch:conclusion}
The present work and its evaluation can be divided into a theoretical and a practical part.
While the former deals with general operating system concepts and their use in Zircon as a newly developed microkernel approach in comparison to the older monolithic Linux kernel, the second part focuses more on their differences in driver development.
The architectures and objectives of microkernel and monolith systems are fundamentally different, whereas the concepts used for basic operating system tasks are often similar.
Overall, however, these are optimized for the use in their respective architecture.
Especially Zircon presents an implementation idea that demonstrates a great deal of knowledge and experience in the field of operating system development and clearly shows that one has learnt from things that are not necessarily optimally solved in Linux, e.g.\ for historical and/or compatibility reasons.
Examples for this are, amongst other things, the handling of system calls or the memory management.
Due to the lack of \ac{posix} compatibility enables a more freely design of systemcalls and adapt them to modern needs, but the enforcement of \acp{vdso} and the use of \texttt{libzircon.so} for all systemcall implementations is interesting from a security aspect, as well.
Regarding memory management, Linux is very architecture dependent.
The multitude of architectures and their associated terms and concepts makes them difficult to understand and use correctly, even for experienced developers.
In this context is Zircon, as far as it can be read from the documentation, much more stringent and simpler.
Without a division into memory areas with explicit meaning for different tasks, both, understanding and development becomes easier for the developer.
On the other hand, there are also concepts used in Zircon, which, based on the experiences with Linux, can be assumed to fail for maintainability reasons with a possible spread of Zircon.
An example is the way Zircon deals with board definition files which was already discussed in section~\ref{sec:cs-zircon}.

The circumstances are similar for the actual driver development as well.
Conceptually, the influences of the microkernel become slightly visible in the lifecycle of a driver, for example when binding the driver to a device and for the selection of the superior device host process.
Within the driver development itself, the differences to Linux are rather caused by the collected experiences and the selection of more modern approaches.
Neither the break with the \ac{posix} standard nor the introduction of \ac{fidl} or the support of a wider range of programming languages in kernel and drivers are direct consequences of an operating system kernel architecture, but a reaction to learnings from Linux and other operating systems.
Nevertheless, exactly these points make the development on Zircon truly pleasant.

Because of the good documentation, the transition to C drivers in Zircon is very smooth, only the documentation for the definition of devices and for board files at a whole are missing.
The change to C++ drivers is much more difficult, because there is hardly any documentation.
Instead make advanced C++ concepts, such as mixins, these drivers much more difficult to understand while the corresponding situation is obvious in a C implementation.
Furthermore, C and C++ \acp{api} are often mixed within already existing C++ drivers in the used version level.
On the one hand because there are no C++ bindings for certain tasks in the used version level, as it is e.g.\ the situation for \ac{fidl}, on the other hand are probably simple inconsistencies an issue.
But if the connections between C and C++ drivers are clear, C++ becomes very interesting and sufficient for driver development.
In this context, it is also interesting to see how the development and language prioritization in Zircon will change when the support for \textit{Rust} is ready for use.
Considering the current Zircon development, the general trend is more to replace C drivers with C++ ones.
Rust could be even more interesting from a security point of view.
However, as a programming language is it not as mature and spreas as C and C++.
Overall, the development workflow for Zircon appears well thought-out and coherent, no matter which programming language or compiler is used.
However, most of the accompanying tools in Zircon are based on \ac{llvm} and therefore, require a clang build.
But Linux slowly allows the use of clang and \ac{llvm} as well, justified with the advantages of the dame tools as known from Zircon.
But none of this toolchains had a noticable influence on the development for what reason a more detailed compiler analysis was skipped.

% seine stärken konnte der mikrokernel vorallem in der tatsächlichen verwendung und dort besonders in ausspielen.
% wärend ein fehler in linux möglicherweise den ganzen kernel lahm legt, kann zircon als microkernel hier deutlich besser  agieren.
% leider ist das genaue verhalten in solchen situationen noch nicht dokumentiert.
% während der entwicklung sind aber zwei situationen ins auge gestochen.
% zum einen das verhalten des treibers bzw device coordinators bei misslungenen initialisierungen in der bind methode, aber auch der umgang mit fehlerhaft typisierten fidl calls.
% kann im ersteren fall ein gerät nicht initialisiert werden  und die bind methode des zugehörigen treibers endet mit bestimmten status codes versucht der device coordinator eine gewisse anzahl von re-tries in der hoffnung, dass temporäre probleme dadurch behoben werden können.
% im anderen fall wird die starke typisierung von fidl calls deutlich. während ein fehlerhafter buffer in einem ioctl call in linux potentiell sehr viel schaden anrichten kann, wird bei der verwendung von fidl schon zu beginn eine prüfung der parameter erfolgt.
% passen diese nicht zum definierten call, so wird die verbindung zwischen user und fidl interface eines treibers resettet.
% So ist es zwar notwendig erneut mit dem treiber in kontakt zu treten, aber falsche paramenter können durch den check, aber auch durch das device host konzept kaum bis begrenzten schaden einrichten.
% In den versuchen der case study bezüglich nutzung der fidl commnads wurde den crashs und fehler nur anhand  informativen logmeldungen des konsole verlangt.
% weitere effekte waren nicht zu beobachten und auch der treiber konnte wie gewohnt weiter verwendet werden.
%


the microkernel was able to play off its strengths mainly in its actual use and especially there in its use.
while a bug in linux might paralyze the whole kernel, zircon can act much better as a microkernel.
unfortunately, the exact behavior in such situations is not yet documented.
but during the development two situations have caught the eye.
on the one hand the behaviour of the driver or device coordinator in case of failed initializations in the bind method, but also the handling of incorrectly typed fidl calls.
in the former case a device cannot be initialized and the bind method of the corresponding driver ends with certain status codes the device coordinator tries a certain number of re-tries in the hope that temporary problems can be solved.
in the other case the strong typing of fidl calls becomes obvious. while a faulty buffer in an ioctl call can potentially cause a lot of damage in linux, when using fidl the parameters are already checked at the beginning.
If these do not match the defined call, the connection between user and fidl interface of a driver will be reset.
So it is necessary to get in contact with the driver again, but wrong parameters can cause little to limited damage by the check, but also by the device host concept.
In the attempts of the case study regarding the use of fidl commnads, the crashes and errors were only requested on the basis of informative log messages from the console.
no further effects were observed and also the driver could be used as usual.

%TODO genau diese effekte gehören zu denen die man versucht sich mit dem microkernel zu erkaufen. 
die daraus resultierenden performance einbußen wurden bereits im vorherigen abschnitt diskutiert.



% - konzepte
    % - how implemented
% - treiber implementierungen
    % - konzeptuelle unterschiede
    % - auswirkungen auf die programmierung
    % - workflow und tools
% - auswirkungen des mikrokernels im betrieb
    % - umgang mit fehlern und ausfällen
    % - benutzung vom user aus
% - performance
% - bewertung im hinblick auf historische entwicklung
% - frage ob es sich lohnt für die vorzüge aber auch die geschwindigkeitseinbußen auf zircon zu wechseln
% -> wie wird sich die performance entwickeln, wie wird sich zircon selbst entwickeln, wird es überhaupt tatsächlich eingesetzt und wenn ja wo?...

