% !TEX root = MasterThesis.tex

\section{Zircon Driver Development}\label{sec:cs-zircon}
By allowing differnt programming languages for device drivers but also the variety of available and legit ways result in the fact that Zircon drivers can not be considered in each detail.
In Linux, the situation was similar, but the ways and resulting drivers in Zircon are noticable more.
This section will focus on the \textit{platform device} driver variants, especially the C one to hold this consideration comparable to the Linux one, but the C++ driver implementation and its anomalies are considered as well because it is special compared to Linux.
Nevertheless, the \textit{two driver} variant should be mentioned, too.
The differenced between both ones are rather reasoned in the way the device is defined and initialized and thus, not crucial.
Similar to Linux, will this section focus on selected driver aspects as well.
The full implementations for all written driver variants are available in the according GitHub repository\footnote{github.com, \url{https://github.com/Allegra42/zircon/tree/i2c-grove-lcd/system/dev/display}}.

\subsection{Prearrangements}
Zircon drivers are always built as a part of the kernel and according user system components at them moment.
Within the corresponding driver directory \texttt{zircon/system/dev} are several subdirectories to group them based on their tasks.
As there is no comparable one to \textit{auxdisplay} on Linux, the probably best matching one is \texttt{display}.
Each driver variant is located in \texttt{display} as an own subdirectory consisting of its source file and a \texttt{rules.mk}, the makefile.
A dedicated and sophisticated build configuration as known from Linux \texttt{Kconfig} system is not available.
If a driver directory contains a valid \texttt{rules.mk}, it is built.
Working with four different driver variant for the same device, this situation leads to expectable issues.
Thus, the \texttt{rules.mk} of each currently not needed driver must be taken off the build, e.g.\ by commenting its content out.

As already discussed uses Zircon the \acf{fidl} rather than \ac{io} controls.
All of these definitions which refer to a module located within \texttt{zircon/system}, i.e.\ a system component that is not part of the actual microkernel, are collected within the directory \texttt{zircon/system/fidl}.
According to the way a driver is modularized, one or more \ac{fidl} definitions are grouped in a subdirectory together with a \texttt{rules.mk} file.
A special compiler generates interface definitions and bindings in the needed languages from the generic \ac{fidl} files.
At the moment, these are most of all C bindings for both sides, a set for the use in drivers and a corresponding one for the use in user applications.
Even if a driver is written in C++ are currently only the C bindings available.
The resulting effects are considered as a part of the following section.

\subsection{Device Definition}
In Linux, the way an \ac{i2c} device is defined for the system was discussed as part of driver initialization.
A corresponding driver function exists but is hardly ever used and the whole binding mechanism in Zircon works slightly different.
Zircon relies on so-called \textit{board files} to define a computing platform such as the Hikey960 is.
Linux previously did the same but changed to the already known \textit{device tree} representation for ARM-based computing devices because the former concept did not scale with the number of supported boards.
ale with the number of supported boards.
The device tree files are a textual representation in an own syntax while board files are written in C on both kernels.
For the actual use are device tree files but board files as well compiled to a binary representation.
However, the device tree can be enhanced during runtime using so-called textit{device tree overlays}.
Today, a comparable mechanism for Zircon board files is not known.

For the actual definition of the Grove-LCD RGB device for the Hikey960 running Zircon, the targeted driver language is not decisive but the kind of the driver.
If both controllers are to be used in standalone driver implementations, e.g.\ neccessary on non platform devices, they must be defined independed from each other as well.
After all, a driver must be able to pick exactly the desired device controller.
In cases a combined \textit{platform device} specific driver is requested, both controllers must be accessable from the same binding sequence.

Listing~\ref{lst:boardfile} pictures the way the devices are defined for both driver kinds.
Line 1 to 13 shows the pure definition of single handled devices on the \ac{i2c} bus.
They are described as an array of a structure consiting of the bus id and the respectively slave address.
The definition for the combined device is pictured in the same listing from line 15 to 24. 
It is nothing else than above but combined both of those definitions in a single one, i.e.\ the array contains both structure elements instead only a single one.
More interesting is the way the device is actually defined in order to be bindable.
The definitions listed so far does not contain any information that allows a matching between device defintion and driver.
Those are added in a second structure which contains a device name, but also entries for a \textit{vendor id (vid)}, a \textit{product id (pid)} and a \textit{device id (did)}.
These id's are decisive for the binding between device and driver.
In order to include the device to be addressed in this structure as well, a pointer of the respectively structure type is added alongside the number of actual device entries in the previous list (see listing~\ref{lst:boardfile}, line 27 to 34 and 36 to 43).

\begin{listing} [H]
\caption{Device Definition in Zircon Boardfiles}
\label{lst:boardfile}
\begin{minted}[frame=lines, framesep=0mm, fontsize=\footnotesize, linenos, breaklines]{c}
static const pbus_i2c_channel_t i2c_grove_rgb_channels[] = {
  {
    .bus_id = 0,
    .address = 0x62,
  },
};

static const pbus_i2c_channel_t i2c_grove_lcd_channels[] = {
  {
    .bus_id = 0,
    .address = 0x3e,
  },
}; 

static const pbus_i2c_channel_t i2c_grove_pdev_channels[] = {
  {
    .bus_id = 0,
    .address = 0x62,
  },
  {
    .bus_id = 0,
    .address = 0x3e,
  },
};


static const pbus_dev_t i2c_grove_lcd_dev = {
  .name = "grove-lcd-i2c",
  .vid = PDEV_VID_SEEED,              
  .pid = PDEV_PID_SEEED,              
  .did = PDEV_DID_SEEED_GROVE_LCD,    
  .i2c_channel_list = i2c_grove_lcd_channels,
  .i2c_channel_count = countof(i2c_grove_lcd_channels),
}; 

static const pbus_dev_t i2c_grove_pdev_dev = {
  .name = "grove-lcd-i2c",
  .vid = PDEV_VID_SEEED,              
  .pid = PDEV_PID_SEEED,              
  .did = PDEV_DID_SEEED_GROVE_PDEV,  
  .i2c_channel_list = i2c_grove_pdev_channels,
  .i2c_channel_count = countof(i2c_grove_pdev_channels),
};
\end{minted}
\end{listing}

As a result, the device definitions for a single driver only contain one element in this \mintinline{c}{i2c_channel_list} while the device definition for the pdev driver holds two of them.
The listing~\ref{lst:boardfile} pictures only the \ac{lcd} definition for the first type.
The one for \ac{rgb} is defined accordingly.
But the idea behind this second device definition goes further.
It does not only allow one or more \ac{i2c} devices but additional ones as well.
This allows to create complex device descriptions, e.g.\ a device consisting of \ac{i2c} parts, \ac{gpio}'s, interrupts and others, and make exacatly this combination of devices accessible to a single driver.
Within the Hikey960 board files, such an approach is for example used to describe the on-board \ac{gpu} which is made from \ac{mmio}, interrupts and \ac{bti} for \ac{dma} transfers.

Thus, the device description in Zircon is much more detailed but very descriptive.
Unfortunately, there is hardly any documentation available on this topic and the binding mechanism in general.
However, the pure definition of the devices is not enough.
If these descriptions are not attached to the object representing the \textit{platform bus} for the Hikey960 using the \mintinline{c}{pbus_device_add()} \ac{api}, no binding is possible at all.
The device is not known without.

\subsection{Driver Binding}
The pure binding or matching mechanism between device definition and driver is the same for C and C++ in both variants as well because for this situation are only C language bindings available at the moment.
Thus, the way a driver defines a matching device is considered for both language versions while the actual \mintinline{c}{bind()} implementation is discussed in the specific sections.
Within C driver implementations, the neccessary code lines are a part of the common driver source code, in C++ they are usually outsourced in a single \texttt{bind.c} file containing these lines and an extern definition of the C++ function signature for \mintinline{c}{bind()}.
While the way for C drivers is well-defined and documented, the implementations of C++ \texttt{bind.c} files differs a lot within the available sources.
These work only discusses the way used within this case study.
The listing~\ref{lst:binding} pictures such a binding definition, to be accurate, the one for the C++ \ac{lcd} driver.
It only differs by the one used for the C one by line 2 which is only needed for C++ and the C++ specific naming within the code.

\begin{listing} [H]
\caption{Driver Binding for the LCD Driver C/C++}
\label{lst:binding}
\begin{minted}[frame=lines, framesep=0mm, fontsize=\footnotesize, linenos, breaklines]{c}
/* C++ specific line */
extern zx_status_t grove_lcd_bind(void* ctx, zx_device_t* parent);

/* Shared part */
static zx_driver_ops_t grove_lcd_cpp_driver_ops = {
  .version = DRIVER_OPS_VERSION,
  .bind = grove_lcd_bind,
};

ZIRCON_DRIVER_BEGIN(grove-lcd-cpp, grove_lcd_cpp_driver_ops, "grove-lcd-cpp", "0.1", 3)
  BI_ABORT_IF(NE, BIND_PLATFORM_DEV_VID, PDEV_VID_SEEED),
  BI_ABORT_IF(NE, BIND_PLATFORM_DEV_PID, PDEV_PID_SEEED),
  BI_MATCH_IF(EQ, BIND_PLATFORM_DEV_DID, PDEV_DID_SEEED_GROVE_LCD),
ZIRCON_DRIVER_END(grove-lcd-cpp)
\end{minted}
\end{listing}

While Linux uses compatible strings for the matching between driver and device offers Zircon a more sophisticated mechanism based on macros.
Listing~\ref{lst:binding} pictures a rather basic example in the lines 10 to 14.
The binding definitions are surrounded by two macros, the \mintinline{c}{ZIRCON_DRIVER_BEGIN()} and \mintinline{c}{ZIRCON_DRIVER_END()}.
With, the actual binding rules are defined.
Zircon allows much more complex sequences to describe the device to be binded than Linux does.
The according listing~\ref{lst:binding} only pictures two types of them.
A full definition is available in \texttt{system/public/zircon/driver/binding.h}.
The first used type is \mintinline{c}{BI_ABORT_IF()}.
In combination with its first argument \mintinline{c}{NE}, the lines 11 and 12 indicate the device coordinator to abort the binding process if the third argument which must be from the type specified as a second argument, not matches the one defined for a device (see~\ref{lst:boardfile}, lines 29 to 30 and 38 to 39).
These type of a rule is used within all drivers written as a part of this thesis to ensure the vendor and product id matches the ones defined for the Grove device definitions.
All of them share exactly these symbolic names pictured in this listing as vendor and product id's.
Only the product id, and thus, the last binding rule pictured in line 13 is different for the particular device types, the \ac{lcd}, the \ac{rgb} and the combined PDev device.
The according binding rule to differ between them is \mintinline{c}{BI_MATCH_IF()} with \mintinline{c}{EQ} as a first argument.
As a result, the whole binding sequence means a device matching to the pictured rule must define \texttt{PDEV\_VID\_SEEED} as a vendor id, \texttt{PDEV\_PID\_SEEED} as a product id and \texttt{PDEV\_DID\_SEEED\_GROVE\_LCD} as a product id.
Accordingly, the pictured rule is for a Grove \ac{lcd} driver, no matter if written in C or C++.
To change it for the \ac{rgb} or PDev one, only the symbolic name in listing~\ref{lst:binding}, line 13 and related naming definitions must be changed.
In common, these are the names used as arguments for \mintinline{c}{ZIRCON_DRIVER_BEGIN/END()}.
But these macros does not only contain the driver's name as an argument, the \mintinline{c}{ZIRCON_DRIVER_BEGIN/END()} takes a reference to a driver operations structure as well.
The structure (see listing~\ref{lst:binding}, line 5 to 8) is not visible as such one at the first sight because Zircon allows type definitions in contrast to Linux.
Within this \mintinline{c}{zx_driver_ops_t}, only two entries must be definied.
The version code must be set to \mintinline{c}{DRIVER_OPS_VERSION}.
It is a pre-defined symbolic name and a requirement for the driver.
The second entry in line 7 is a function pointer to the driver's \textit{bind} implementation, i.a.\ the corresponding function to Linux' \texttt{probe()}.
If the binding sequence matches a device, this function is the one to be called.
Similar to Linux, its task is to setting up driver and device for use.

As already mentioned is the second line, the extern definition of the \texttt{bind()} function signature only needed for C++ drivers as the binding routine and the actual implementation of  \texttt{bind()} are done in different source files and programming languages.
In a pure C driver, it is not needed at all.

One further special situation about these binding rules is the fact they are defined as a part of the driver but located in a defined binary segment which allows the device coordinator to access them without loading a whole driver into its address space.
The full driver is not loaded before a matching device is found and its \mintinline{c}{bind()} function referenced in \mintinline{c}{zx_driver_ops_t} is actually called.

\subsection{C-Driver}

\subsubsection{Driver Binding and Release}\label{sec:zircon:drv:bind}
After a match between driver and device is found by the device coordinator, the complete driver is loaded into the device host process of a superior device.
At this point, the drivers execution starts by calling its \mintinline{c}{bind()} function with these parent device as an argument.

Zircon driver code seems unfamiliar at the first sight if switching from Linux, e.g.\ because of naming, function signatures and coding style.
But the structure within is similar.
As a first step, memory for instance specific driver data is allocated.
The previous section mentioned already that the coding style used in Zircon prefers type definitions over structures for C drivers. 
Thus, the type \mintinline{grove_t} is introduced for this situation.
The data stored within is comparable to the one stored in the Linux equivalent.
It contains, besides other entries that are considered as soon as they are needed, ones for the \ac{i2c} objects but also entries to store the device' current state.
Unlike Linux, the actual memory allocation for this type is done via \mintinline{c}{calloc()}, a standard C library function (see listing~\ref{lst:bindfunc}, line 4 to 7).
Obviously, error handling in form of checking if the pointer to the resulting memory regions is valid, is needed in Zircon as well.

The next call is a kind of platform device specific.
It fetches the protocol device for this driver, in this case for the \texttt{PDev} protocol (see listing~\ref{lst:bindfunc}, line 9 to 13).
This will turn this driver implementation into a platform device specific one.
A driver which is not addicted to platform devices would fetch the \mintinline{c}{ZX_PROTOCOL_I2C} instead, in this situation.
The result of this call is a \mintinline{c}{pdev_protocol_t} typed object which represents the platform device instance.
It is needed to fetch associated devices on the platform bus.
For this driver, these are both \ac{i2c} devices of the Grove-LCD RGB backlight.
They are allocated using the call \mintinline{c}{pdev_get_protocol()} pictured in listing~\ref{lst:bindfunc}, line 16 to 25}.
The call is very similar to the previously used one to fetch the platform device.
It uses this one as a parent instead of the one given as a call argument to the bind function.
The fetched protocol is, of course, \mintinline{c}{ZX_PROTOCOL_I2C} and the resulting object is stored as a \mintinline{c}{i2c_protocol_t} within the \mintinline{c}{grove_t} structure.
But to fetch the desired device from the both possible ones defined in listing~\ref{lst:boardfile}, an additional call argument is needed.
It is a number to describe the position within the \mintinline{c}{pbus_i2c_channel_t} array (see listing~\ref{lst:boardfile}, line 15 to 24).

Unlike Linux \mintinline{c}{probe()}, Zircon's \mintinline{bind()} does not need that much kernel internal driver setup and registration in various infrastructure elements.
The only similar action a Zircon driver must perform is adding a device below the parent via the \mintinline{c}{device_add()} call in listing~\ref{lst:bindfunc}, line 35.
This call adds this device instance to the system using the arguments defined in line 27 to 33.
For this reason, the structure contains a pointer to the driver operations (line 31), i.a.\ the \ac{fidl} operations on this platform device driver.
The issue known from Linux, make the private driver instance data available through the whole driver including the file operations and other interfacing options is solved more sophisticated in Zircon.
Already this arguments structure contains it as a so-called \textit{context pointer} \texttt{ctx}.
It is a void pointer and thus, capable of own type definitions.

\begin{listing} [H]
    \caption{Implementation of the \texttt{bind()} Function within the Zircon Platform Device Driver in C}
\label{lst:bindfunc}
\begin{minted}[frame=lines, framesep=0mm, fontsize=\footnotesize, linenos, breaklines]{c}
static zx_status_t grove_bind(void* ctx, zx_device_t* parent) {
    zx_status_t status;

    grove_t* grove = calloc(1, sizeof(*grove));
    if (!grove) {
        return ZX_ERR_NO_MEMORY;
    }

    if (device_get_protocol(parent, ZX_PROTOCOL_PDEV, &grove->pdev) != ZX_OK) {
        free(grove);
        zxlogf(ERROR, "Failed to fetch the PDEV protocol for the grove lcd rgb driver - not supported\n");
        return ZX_ERR_NOT_SUPPORTED;
    }

    size_t actual;
    if (pdev_get_protocol(&grove->pdev, ZX_PROTOCOL_I2C, 0, &grove->i2c_rgb, sizeof(grove->i2c_rgb), &actual) != ZX_OK) {
        free(grove);
        zxlogf(ERROR, "Failed to fetch the I2C protocol (rgb) for the grove lcd rgb driver - not supported\n");
        return ZX_ERR_NOT_SUPPORTED;
    }
    if (pdev_get_protocol(&grove->pdev, ZX_PROTOCOL_I2C, 1, &grove->i2c_lcd, sizeof(grove->i2c_lcd), &actual) != ZX_OK) {
        free(grove);
        zxlogf(ERROR, "Failed to fetch the I2C protocol (lcd) for the grove lcd rgb driver - not supported\n");
        return ZX_ERR_NOT_SUPPORTED;
    }

    device_add_args_t args = {
        .version = DEVICE_ADD_ARGS_VERSION,
        .name = "grove-pdev-drv",
        .ctx = grove,
        .ops = &grove_device_protocol,
        .flags = DEVICE_ADD_INVISIBLE,
    };

    if ((status = device_add(parent, &args, &grove->device)) != ZX_OK) {
        free(grove);
        return status;
    }

    thrd_t thrd;
    int thrd_ret = thrd_create_with_name(&thrd, grove_init_thread, grove, "grove_init_thread");
    if (thrd_ret != thrd_success) {
        status = thrd_ret;
        device_remove(grove->device);
        free(grove);
    }

    return status;
}
\end{minted}
\end{listing}

Beside these entries, the structure contains a version code, the driver name to be shown and maybe additional flags.
These flags influence, among other things, the way a device is added to the system.
The implementation pictured uses \mintinline{c}{DEVICE_ADD_INVISIBLE} as a flag.
It should be used for device drivers with long running initializations.
The idea behind is to add a devices representation already to the system and leave the \mintinline{c}{bind()} function but hide it from users until the initialization is done.
One or more of such long running operations are in common done as possibly in parallel running threads.
If the initialization finishes successfully, the driver implementation must switch the device state to visible while a failed one was not spotted by users at all.

The device initializations for both Grove parts are not that long and it would probably be fine to initialize them using as sequential function.
However, Zircon does not define precise rules for this situation.
For this reason, the actual device initialization is implemented in the thread version in C and the sequential one in C++.
The code pictured in listing~\ref{lst:bindfunc}, line 40 to 46 uses a single thread for both initializations which is considered in detail within the following section.
As the thread creation takes the driver context as an argument as well, it enables the access to the needed \ac{i2c} instances without further ado.
The used Zircon driver implementation returns a status code which is needed for a proper error handling.
However, if the device initialization fails, the only situation occurs in which a call must be revoked within the whole binding function.
The already added device must be removed and, as always, the \mintinline{c}{grove_t} instance must be freed (see listing~\ref{lst:bindfunc}, line 42 to 46).

As pictured, Zircon does not need a sophisticated driver setup as known from Linux and as a result, not that much memory allocations in \mintinline{c}{bind()}.
At the same time, it is not needed to undo the most calls done during this function.
As a result, the error handling is, in this case, less complex than known from Linux.
Using jump marks for clean up is not needed, thus, but valid in Zircon as well.

Accordingly, the \mintinline{c}{release()} implementation is very simple and short as well and thus, not pictured here.
The device should be removed and the context data must be freed.
However, it is rare this function is called according to the driver lifecycle discussed in section~\ref{sec:zirconlifecycle}.

The mentioned actual device initialization is very similar to the way it is done in Linux.
Thus, this section focuses on the Zircon specific parts and considers only the \ac{lcd} initialization.
The \ac{rgb} one is part of this thread function as well, but skipped in this context.
Data transfers on the \ac{i2c} bus are also critical sections in Zircon, so it is needed to lock them just like in Linux (see listing~\ref{lst:zirconinit}, line 4), but the lock variable \mintinline{c}{lock} is managed as a part of the \mintinline{c}{grove_t} instance instead as a global variable.
Overall, in Zircon is it avoided to use global variables at all, while static defines, e.g.\ for fixed values are allowed.
Everything else should be a part of a device instance context.
After the section is locked, the way \ac{i2c} transactions are done does not differ from Linux except the available kernel \ac{api} calls.
It is because the Linux implementation was inspired by Zircon.
Defining a structure respectively a data type for the register and according value tupels, build an array containing the needed sequence (see listing~\ref{lst:zirconinit}, lines 7 to 12) and send it using a loop over this array (lines 14 to 20) was discovered as a commonly used pattern in Zircon.

\begin{listing} [H]
    \caption{Device Initialization in a Zircon Platform Device Driver (C)}
\label{lst:zirconinit}
\begin{minted}[frame=lines, framesep=0mm, fontsize=\footnotesize, linenos, breaklines]{c}
static int grove_init_thread(void* arg) {
    grove_t* grove = arg;

    mtx_lock(&grove->lock);
    /* RGB initialization is skipped */

    i2c_cmd_t setup_cmds[] = {
        {LCD_CMD, 0x01},
        {LCD_CMD, 0x02},
        {LCD_CMD, 0x0c},
        {LCD_CMD, 0x28},
    };

    for (int i = 0; i < (int)ARRAY_SIZE(cmds); i++) {
        status = i2c_write_sync(&grove->i2c_lcd, &setup_cmds[i].cmd, sizeof(setup_cmds[0]));
        if (status != ZX_OK) {
            zxlogf(ERROR, "grove-lcd: write to i2c device failed\n");
            goto init_failed;
        }
    }

    status = i2c_write_sync(&grove->i2c_lcd, "@Initialized", 12);
    if (status != ZX_OK) {
        zxlogf(ERROR, "grove-lcd: write to i2c device failed\n");
        goto init_failed;
    }

    mtx_unlock(&grove->lock);
    device_make_visible(grove->device);
    return ZX_OK;

init_failed:
    zxlogf(ERROR, "grove init thread failed\n");
    mtx_unlock(&grove->lock);
    return ZX_ERR_IO;
}
\end{minted}
\end{listing}

It is better readable but as well more flexible than writing the commands hard coded into the \ac{i2c} \acp{api} and reduces redundant code at the same time.
Using this pattern, an additional step in the initialization sequence requires only an extra entry in the \mintinline{c}{i2c_cmd_t} array but not change in the write logic.
The used loop determines the array's size and does the action, the \mintinline{c}{i2c_write_sync()} for all tupels within.
Thereby is the \ac{i2c} write call similar to the one invoked on Linux.
Indeed, there is no \ac{api} to write a single byte value into a controller register, but the call pictured in listing~\ref{lst:zirconinit}, line 15 takes the desired \ac{i2c} representation as a first argument as well.
The following argument differs.
It is the address to an element in the array, which represents the target register on the controller.
From this point, the call works like the one used to send strings in Linux.
The last argument is not a single value to be written in the named register but a number of bytes to be transfered.
As already known from Linux is the first one interpreted as a target register while all following one are written in it.
To leave the loop correctly in case of an error does this function implementation take advantage of jumps.
The error routine must unlock the mutex and exit the thread with a certain error code which allows a proper tear down of the failed driver in the calling function (see listing~\ref{lst:zirconinit}, lines 18 and 32 to 35).

If the initialization of both partital devices was successful so far, an example text is set to the \ac{lcd}.
It shows to a user that the display is initialized and ready for use.
With the available Zircon \ac{api} for writing \ac{i2c} transfers, the idea for texts stays the same as already pictured for Linux.
The target register is encoded as an \ac{ascii} character and prefixes the actual text to be shown.
As discussed previously must the terminating, non-printable character of a string be cutted off at sending to prevent display errors.

However, the probably most important task of this function is, after the initialization was finished successfully, to change the device visibility in Zircon's device filesystem.
This is done using the call \mintinline{c}{device_make_visible()}, pictured in listing~\ref{lst:zirconinit}, line 29.
From this moment on, its representation and thus the actual Grove device, is accessable by users via the interfacing options defined via the \mintinline{c}{.ops} field in the \mintinline{c}{device_add_args_t} (see listing~\ref{lst:bindfunc}, line 31).

\subsubsection{Driver Interfaces}
In accordance with the concept drawn up previously, the Zircon platform device driver receives only a \ac{fidl} interface.
The common file operations \mintinline{c}{read()} and \mintinline{c}{write()} are considered in the following section for the two-driver version.

All \ac{fidl} definitions for the Grove-LCD RGB backlight driver variants are defined within the directory \texttt{system/fidl/zircon-display-grove/} in the Zircon sources.
It contains tree single definitions, one for the platform device variant and two of them for the single controllers.
Thereby is the first variant split into the controller specific parts for the \ac{lcd} and \ac{rgb} definitions.
The defined function signatures does not change between both variants.
Besides the \ac{fidl} files, the directory contains a \texttt{rules.mk} file as well.
It bundles the make rules for all of them in a single file.
Do reach distinct outouts, the built modules get a name extentions.
In common, they are named according the current directory but to build all \ac{fidl} files in a single directory with only one \texttt{rules.mk}, the module names are extended with e.g.\ \texttt{.pdev} for the platform device definition or \texttt{.rgb} for the \ac{rgb} specific one. 
The compiled results are available in the build directory unter the path \texttt{build-arm64/system/fidl/zircon-display-grove.pdev} for the platform device.
The other ones are named according their extentions.
Important for the further driver development is the generated header file with the function signatures for driver and user.
It must be include in the source file and the whole directory must be referenced in the driver's \texttt{rules.mk} by adding the additiona line \mintinline{c}{MODULE_FIDL_LIBS := system/fidl/zircon-display-grove.pdev} in order to be linked correctly.
Within the source file, it is sufficient using \mintinline{c}{zircon/display/grove/pdev/c/fidl.h} as an include path.

\begin{listing} [H]
    \caption{FIDL Definitions for a Zircon Platform Device Driver (C)}
\label{lst:fidldef}
\begin{minted}[frame=lines, framesep=0mm, fontsize=\footnotesize, linenos, breaklines]{c}
library zircon.display.grove.pdev;

[Layout="Simple"]

interface Pdev {
    1:SetColor(uint8 red, uint8 green, uint8 blue);
    2:GetColor() -> (uint8 red, uint8 green, uint8 blue);
    3:ClearLcd();
    4:WriteFirstLine(uint8 position, string:32 line);
    5:WriteSecondLine(uint8 position, string:32 line);
    6:ReadLcd() -> (string:32 content);
    7:GetLineSize() -> (uint8 linesize);
};
\end{minted}
\end{listing}

It is the path to the header definition starting in the mentioned directory's \texttt{gen/include/zircon} record.

The actual interface definitions are pictured in listing~\ref{lst:fidldef}.
It's C-like syntax is simple to use, but with some pitfalls.
The definition for interface number 3 in line 8 is very simple.
It is a void call and thus without call arguments.
More complex ones as number 1 in line 6 take one or more primitive datatype as arguments.
Return values, e.g.\ as defined for interface number 2 in line 7 are defined using a \texttt{-> (<type>)} after the actual call interface.
The return value might consist of more than one value.
An anomaly is the way strings are defined as in or out parameters in the \ac{fidl} syntax.
Using the \textit{simple} layout needed for device drivers, a string as datatype definition must be followed by its maximum transfer size (see listing~\ref{lst:fidldef}, lines 9 to 11).

%TODO
Within the driver, the \ac{fidl}..

\begin{listing} [H]
    \caption{Driver Interfaces via FIDL in a Zircon Platform Device Driver (C)}
\label{lst:fidlinit}
\begin{minted}[frame=lines, framesep=0mm, fontsize=\footnotesize, linenos, breaklines]{c}
static zx_protocol_device_t grove_device_protocol = {
    .version = DEVICE_OPS_VERSION,
    .release = grove_release,
    .message = grove_fidl_message,
};

static zx_status_t grove_fidl_message(void* ctx, fidl_msg_t* msg, fidl_txn_t* txn) {
    zx_status_t status = zircon_display_grove_pdev_Pdev_dispatch(ctx, txn, msg, &fidl_ops);
    return status;
}

static zircon_display_grove_pdev_Pdev_ops_t fidl_ops = {
    .SetColor = grove_fidl_set_color,
    .GetColor = grove_fidl_get_color,
    .ClearLcd = grove_fidl_clear_lcd,
    .WriteFirstLine = grove_fidl_write_first_line,
    .WriteSecondLine = grove_fidl_write_second_line,
    .ReadLcd = grove_fidl_read_lcd,
    .GetLineSize = grove_fidl_get_line_size,
};
\end{minted}
\end{listing}


\subsubsection{Two Driver Variant} 

\subsection{C++-Driver}
% \subsubsection{Platform Device Variant}
 


\section{User Application}

\section{Performance Comparison}

