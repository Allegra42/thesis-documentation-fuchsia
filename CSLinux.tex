% !TEX root = MasterThesis.tex

\chapter{Case Study: Driver Development in Linux and Zircon}\label{ch:case-study}
Device drivers are an integral part of operating systems and require a good knownledge about the peripheral device and its controller, the hardware interface between device and computer and the target operating system from the programmer.
The fundamental operating system principles and their realization were already established in the previous chapter.
But the question of what a device driver actually is and its responsibility was not discussed so far.
Therefore, answering this questions is a valid entry point to the actual case study about the driver models in Linux and Zircon and the exemplarily device driver development.

A device driver's main purpose is providing an abstraction between user applications and peripheral devices\cite{glatz2015betriebssysteme}.
A common programmer should not have to think about the way a specific device is controlled.
Especially as even devices from the same type differ in the exact way the are managed, it would require too much knowledge in applications and make them very error-prone.
Thus, it is the task of a driver as a part of an operating system to 
\begin{itemize}
    \item define an abstraction of a device to the system,
    \item do the connection between applications and a certain peripherals, 
    \item initialize the peripheral controler and the device if it is needed,
    \item query the device state from the controller,
    \item log events,
    \item provide a consistent \ac{api} for all devices from the same type to the user,
    \item receive abstract application requests and translate them to commands which can be submitted to the device and
    \item transfer data from and to the device\cite{glatz2015betriebssysteme},~\cite{tanenbaum-modern-operating-systems}.
\end{itemize}
%
Driver development is very operating system dependent and has wide-ranging consequeces.
While the decision if drivers are located in user or kernel space goes alongside with the choice for an architecture, remain some further questions.
Some of them are about the way and point in time a driver is attached to the operating system.
For example if the driver must be known at compile time or if it is possible to attach it later, e.g.\ during runtime\cite{tanenbaum-modern-operating-systems}.
In any case, each system should provide a unified but extensible device driver interface which supports various device types, even for those that were non-existing at the time the operating system was designed\cite{glatz2015betriebssysteme}.
The design of the interface could be specific to each device typ or standardized for all drivers\cite{tanenbaum-modern-operating-systems}.
Furthermore, in almost every operating system specific driver model, it has to be ensured a driver is \textit{reentrant}, which means a running driver must be safe if it is called from several processes at the same time, and also still safe if peripheral devices become added or removed while the computer is still running\cite{tanenbaum-modern-operating-systems}.
In order to avoid re-developing or duplicating driver parts that remain the same for devices of the same type are device drivers often modelled and implemented as a hierarchical or layered model.
A possibility is to split into a logical and a physical layer.
The logical one contains driver functionality which remains consistent between same typed devices while the physical layer only takes care of device specific functionality\cite{tanenbaum-modern-operating-systems} 

% \section{Driver Models}
  
\section{Linux Driver Model}
As already mentioned, drivers do most of all an abstraction of the communication with \ac{io} peripherals.
To do so, Linux provides more ways than widely known.
The first one is via \textit{direct hardware access} as \textit{user-space driver}.
As known from the previous sections are the most \ac{io} respectively driver related operations privileged.
But Linux offers a way for common user applications (userspace) to access hardware without a classical driver using this possibility.
It is, above all, used for video drivers which are incorporated into the \textit{X.Org display server}.
In order to obtain the neccessary rights are two systemcalls needed: \texttt{iopl()} to change the privileged level and \texttt{ioperm()} to set the \ac{io} port permissions.
These calls can only be done by a privileged Linux user, the \textit{root} user.
Compared to other options to access peripheral hardware, this one has the disadvantage that interrupts are to available at all and the user software may run into issues with demand paging.
So this way is maybe slower than a device driver in kernelspace, but for some tasks, like the already named \textit{X.Org server} is it more meaningful than a kernel driver\cite{lfd430},~\cite{glatz2015betriebssysteme}.

Another widely unknown and \ac{cpu} specific way to perform \ac{io} operations is using \textit{minimal operating system support} to access serial interfaces on x86-based \acp{cpu}.
In doing so, the kernel does not know anything about the exact device but about its \ac{io} interface\cite{glatz2015betriebssysteme}.
Thus, this variant is not handled further.
Instead, this work will focus on \ac{io} drivers in \textit{kernel-space}, the most common way device drivers in Linux are written.
This kind of driver is a part of the kernel's address space, running in the \ac{cpu}'s kernel mode and thus privileged.
User applications can access kernel drivers and thus the devices via common file operations like \texttt{open()}, \texttt{close()}, \texttt{read()} or \texttt{write()} as they are shown virtually as \textit{special files} in the device filesystem \texttt{/dev/}.
Together with the optional entries in the \texttt{/sys/} filesystem and the older ones in \texttt{/proc/} are devices in those filesystems categorized in a structured way, according their types\cite{glatz2015betriebssysteme}.
Linux differentiates drivers in the already known block devices, character devices and network devices, but internally are drivers structured in \textit{subsystems} of similar device functionality like usb, network, bluetooth, gpio and many others\cite{quade2016Linux}. 

As indicated above do \textit{character} and \textit{block device drivers} in Linux have filesystem entries which are associated with them.
Such a file node is the basic way to communicate with the driver from userspace.
The fundamental \texttt{/dev/} directory but also the \texttt{/sys/} and \texttt{/proc/} are virtual.
They require not more disk space than the needed inodes.
A device is identified by a \textit{device number} which is composed of a \textit{major number} to identify the device itself and the \textit{minor number} to count the existing device instances\cite{lfd430}.
Device numbers are in the most cases assigned by the \textit{udev} mechanism today.
A closer look to it and its relation to the \texttt{/sys/} filesystem follows.

\textit{Character devices}, no matter in which subsystem they are arranged, have in common that they are well represented as data streams.
They provide only sequential access to their data and can be considered as file including the standard file operations\cite{lfd430}.
The same applies to \textit{block devices}.
In contrast to character devices are block devices read and written only in multiples of their block-size.
Linux enables devices of these type to behave similar to character devices and transfer any number of bytes per time, too\cite{lfd430}.
Random data access is also allowed and the access to their data is usually cached.
One characteristic of block devices is the fact a \textit{filesystem} can be mount on the device.
Thus, file operations are of course available on them.
Examples are hard drives or USB memory sticks\cite{lfd430}.
The third device class, \textit{network devices}, are different at all.
They transfer \textit{packets} of data.
Network devices are not mapped as files or provide file operations.
Instead, they are most often identified by name (\texttt{eth0}, \texttt{wlan0}) and accessed via the \textit{Berkeley socket} interface\cite{lfd430}.




\cite{quade2016Linux}
needed driver functionalities: 
- functions to include itself into the system (init/ deinit functions)
- application triggered functions (open, close, read, ..)
- os triggered functions: ISR, \ldots


driver routines
- integration of driver routines  (standardized io fuctions) via data structures which are declared to the system via special calls
- the structues are a list of function pointers for the actual implementation of the standardized prototype
- not used/implemented functions get a null pointer

\cite{quade2016Linux}
-> different driver interfaces
    - standard api (open, close, read, write, ioctl)
    - communication api
    - multimedia interfaces \ldots

    interfaces are realized by using defined datastructures and ioctls to avoid to enhance the systemcall interface

data exchange between kernel and userspace
- functions like write / read / (ioctl, sysfs, procfs) may need to copy data between user and kernel
- copy between user and kernel address space -> special system function: copy_from_user, copy_to_user, put_user, get_user
- driver buffers are alway in main mem, user buffer may are swapped out to sidk
\cite{lfd430}
- different address spaces between user and kernel -> addresses are not meaningful in another address space
-> use built in functions
-> use memory mapping (mmap), standard posix system call -> user is given direct access to kernel memory buffers (may be memory regions directly on a device) -> avoid buffering or caching data -> longer time to setup and shutdown than copy_to_user
->> do never access normal files from kernelspace

\cite{lfd430}
unified device model
- all devices handled under this scheme are handled in one framework with similar data structures and functional methods
- the framework is represented as a device tree rooted on the system buses
- drivers mostly do not need directly with the model but register under the type of bus they are connected, e.g. pci, usb\ldots
- information about the device is exposed in sysfs
- drivers can optionally export additional data for view/modify -> modern alternative to procfs and ioctl



static vs dynamic driver integration
- older unix/linux systems used only a static integration -> all (may) needed drivers must be present -> size
    - no new drivers during a system is running
    - crashing driver is down
- dynamic modules (additionally) 
    - dynamic loadable kernel modules with optional parameters -> allow starting and stopping from drivers without reboot
    - needs two (additional) functions for proper starting and stopping of the module
    - load via insmod/modprobe, unload via rmmod -> does a dynamic binding to the kernel symbol table -> only public kernel apis available

\cite{quade2016Linux}
    static built-> built-in or kernel driver -> regenerate kernel each time a new driver is needed
    dynamic : load a module to an active kernel -> module driver -> better for driver tests, just compile a new module instead a new whole kernel, no need for reboots, may spread as a module -> needs to match the exact kernel version
    not each driver is realizable as a module, e.g. the disk driver is needed to early after system start to be a module

\cite{lfd430}
directly in kernel or as a module -> does require little or no change of the source


driver software must be reentrant!

\cite{lfd430}
mechanism vs policy -> mechanism in kernel, policy in userspace

% \cite{lfd430}
% char drivers
%
% - char & block devices have filesystem entries associated with them -> node is used by user level to communicate with the device
% - such a file is a special entry, not a real file -> needs no diskspace, just the record for the inode
% - device is identified by a device number (major and minor before)
% - major: device, minor: different instances of the device
% - in common dynamically allocated by the udev mechanism
% - dev node is accessed from user with file operations: open, close, read, write, ioctl, mmap, poll -> for all of them is default behaviour available

% \cite{quade2016Linux}
% stacked drivers
% - many drivers are made from different layers: low level, core high-level)
% - low level: for control of the internal hardware interface, eg. a usb controller
% - high level: for the device typ: e.g. a web cam
% - core level: enhances the internal interface with device specific functionality -> tries to find the right driver for a device
%
% \cite{lfd430}
% -> not stacked each time, e.g. usb is stacked


\section{Zircon Driver Model}

\section{Test Setup}

\subsection{Hardware Issues}
% 1.8 vs 5V
%
% The RGB LCD has 2 chips with 2 different functionalities. One of it drives the LEDs and the other one drives the text that’s printed.
%
% The text driver is one and only and has an address of 0x3e.
%
% The LED driver has multiple addresses, of which we only need one. As it’s specified on page 8 (annex 7.1.1) in this datasheet (aka PCA9633) 9, there are 3 fixed addresses for our 8-pin chip package (the PCA9633):
%
% address 0x70 - LED all call address - it’s on at startup and cannot be addressed individually
%
% address 0x03 - Software reset address - it’s on at startup and cannot be addressed individually
%
% address 0x62 - Slave address - it’s the one you are communicating with and is addressable
%
% raspi pi@raspberrypi:~\$ i2cdetect -y 1
    % 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
% 00:          03 -- -- -- -- -- -- -- -- -- -- -- --
% 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- 3e --
% 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 60: -- -- 62 -- -- -- -- -- -- -- -- -- -- -- -- --
% 70: 70 -- -- -- -- -- -- --
%
%
% root@linaro-developer:~# i2cdetect -y -r 0
    % 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
% 00:          -- -- -- -- -- -- -- -- -- -- -- -- --
% 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 60: -- -- 62 -- -- -- -- -- -- -- -- -- -- -- -- --
% 70: 70 -- -- -- -- -- -- --
%
% https://www.kernel.org/doc/Documentation/i2c/instantiating-devices
% https://www.kernel.org/doc/Documentation/i2c/writing-clients
% https://raw.githubusercontent.com/torvalds/linux/v4.20/include/linux/i2c.h
% https://i2c.wiki.kernel.org/index.php/OF_Modalias



\section{General Driver Concept}\label{sec:cs-driver-concept}


\section{Linux}\label{sec:cs-linux}


\subsection{Driver Implementation} %TODO better titel, label
\subsubsection{Interface} %ioctl
    % Development setup for x86-64, ARM64, ...
