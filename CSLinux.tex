% !TEX root = MasterThesis.tex

\chapter{Case Study: Driver Development in Linux and Zircon}\label{ch:case-study}
Device drivers are an integral part of operating systems and require a good knownledge about the peripheral device and its controller, the hardware interface between device and computer and the target operating system from the programmer.
The fundamental operating system principles and their realization were already established in the previous chapter.
But the question of what a device driver actually is and its responsibility was not discussed so far.
Therefore, answering this questions is a valid entry point to the actual case study about the driver models in Linux and Zircon and the exemplarily device driver development.

A device driver's main purpose is providing an abstraction between user applications and peripheral devices\cite{glatz2015betriebssysteme}.
A common programmer should not have to think about the way a specific device is controlled.
Especially as even devices from the same type differ in the exact way the are managed, it would require too much knowledge in applications and make them very error-prone.
Thus, it is the task of a driver as a part of an operating system to 
\begin{itemize}
    \item define an abstraction of a device to the system,
    \item do the connection between applications and a certain peripherals, 
    \item initialize the peripheral controler and the device if it is needed,
    \item query the device state from the controller,
    \item log events,
    \item provide a consistent \ac{api} for all devices from the same type to the user,
    \item receive abstract application requests and translate them to commands which can be submitted to the device and
    \item transfer data from and to the device\cite{glatz2015betriebssysteme},~\cite{tanenbaum-modern-operating-systems}.
\end{itemize}
%
Driver development is very operating system dependent and has wide-ranging consequeces.
While the decision if drivers are located in user or kernel space goes alongside with the choice for an architecture, remain some further questions.
Some of them are about the way and point in time a driver is attached to the operating system.
For example if the driver must be known at compile time or if it is possible to attach it later, e.g.\ during runtime\cite{tanenbaum-modern-operating-systems}.
In any case, each system should provide a unified but extensible device driver interface which supports various device types, even for those that were non-existing at the time the operating system was designed\cite{glatz2015betriebssysteme}.
The design of the interface could be specific to each device typ or standardized for all drivers\cite{tanenbaum-modern-operating-systems}.
Furthermore, in almost every operating system specific driver model, it has to be ensured a driver is \textit{reentrant}, which means a running driver must be safe if it is called from several processes at the same time, and also still safe if peripheral devices become added or removed while the computer is still running\cite{tanenbaum-modern-operating-systems}.
In order to avoid re-developing or duplicating driver parts that remain the same for devices of the same type are device drivers often modelled and implemented as a hierarchical or layered model.
A possibility is to split into a logical and a physical layer.
The logical one contains driver functionality which remains consistent between same typed devices while the physical layer only takes care of device specific functionality\cite{tanenbaum-modern-operating-systems} 

% \section{Driver Models}
  
\section{Linux Driver Model}
\subsubsection*{Driver Types}
As already mentioned, drivers do most of all an abstraction of the communication with \ac{io} peripherals.
To do so, Linux provides more ways than widely known.
The first one is via \textit{direct hardware access} as \textit{user-space driver}.
As known from the previous sections are the most \ac{io} respectively driver related operations privileged.
But Linux offers a way for common user applications (userspace) to access hardware without a classical driver using this possibility.
It is, above all, used for video drivers which are incorporated into the \textit{X.Org display server}.
In order to obtain the neccessary rights are two systemcalls needed: \texttt{iopl()} to change the privileged level and \texttt{ioperm()} to set the \ac{io} port permissions.
These calls can only be done by a privileged Linux user, the \textit{root} user.
Compared to other options to access peripheral hardware, this one has the disadvantage that interrupts are to available at all and the user software may run into issues with demand paging.
So this way is maybe slower than a device driver in kernelspace, but for some tasks, like the already named \textit{X.Org server} is it more meaningful than a kernel driver\cite{lfd430},~\cite{glatz2015betriebssysteme}.

Another widely unknown and \ac{cpu} specific way to perform \ac{io} operations is using \textit{minimal operating system support} to access serial interfaces on x86-based \acp{cpu}.
In doing so, the kernel does not know anything about the exact device but about its \ac{io} interface\cite{glatz2015betriebssysteme}.
Thus, this variant is not handled further.
Instead, this work will focus on \ac{io} drivers in \textit{kernel-space}, the most common way device drivers in Linux are written.
This kind of driver is a part of the kernel's address space, running in the \ac{cpu}'s kernel mode and thus privileged.
User applications can access kernel drivers and thus the devices via common file operations like \texttt{open()}, \texttt{close()}, \texttt{read()} or \texttt{write()} as they are shown virtually as \textit{special files} in the device filesystem \texttt{/dev/}.
Together with the optional entries in the \texttt{/sys/} filesystem and the older ones in \texttt{/proc/} are devices in those filesystems categorized in a structured way, according their types\cite{glatz2015betriebssysteme}.
Linux differentiates drivers in the already known block devices, character devices and network devices, but internally are drivers structured in \textit{subsystems} of similar device functionality like usb, network, bluetooth, gpio and many others\cite{quade2016Linux}. 

As indicated above do \textit{character} and \textit{block device drivers} in Linux have filesystem entries which are associated with them.
Such a file node is the basic way to communicate with the driver from userspace.
The fundamental \texttt{/dev/} directory but also the \texttt{/sys/} and \texttt{/proc/} are virtual.
They require not more disk space than the needed inodes.
A device is identified by a \textit{device number} which is composed of a \textit{major number} to identify the device itself and the \textit{minor number} to count the existing device instances\cite{lfd430}.
Device numbers are in the most cases assigned by the \textit{udev} mechanism today.
A closer look to it and its relation to the \texttt{/sys/} filesystem follows.

\textit{Character devices}, no matter in which subsystem they are arranged, have in common that they are well represented as data streams.
They provide only sequential access to their data and can be considered as file including the standard file operations\cite{lfd430}.
The same applies to \textit{block devices}.
In contrast to character devices are block devices read and written only in multiples of their block-size.
Linux enables devices of these type to behave similar to character devices and transfer any number of bytes per time, too\cite{lfd430}.
Random data access is also allowed and the access to their data is usually cached.
One characteristic of block devices is the fact a \textit{filesystem} can be mount on the device.
Thus, file operations are of course available on them.
Examples are hard drives or USB memory sticks\cite{lfd430}.
The third device class, \textit{network devices}, are different at all.
They transfer \textit{packets} of data.
Network devices are not mapped as files or provide file operations.
Instead, they are most often identified by name (\texttt{eth0}, \texttt{wlan0}) and accessed via the \textit{Berkeley socket} interface\cite{lfd430}.

\subsubsection*{Driver Build Types}
Device drivers in Linux can be a static part of the kernel or a dynamically loadable \textit{module}.
In older version, only a static integration was possible. That means all may needed drivers must be present at compile time.
Thus, the kernel size increases but some drivers will not be used at all and to add a new driver is it needed to recompile and reboot the kernel.
Current Linux kernels allow additionally the dynamically loadable modules with optional parameters.
Reload a driver during runtime without a reboot does not only saves space, it is also useful for development.
It is only needed to recompile and reload a single module instead of the entire kernel including a system reboot\cite{quade2016Linux}.
However, the module has to be built to exactly the same kernel module as running in order to be loaded.
A module which is dynamically loaded via \texttt{insmod} respectively \texttt{modprobe} is, like built-in drivers, a part of the kernel's address space and running in kernel mode.
But as a module does a dynamic binding to the kernel's symbol table, it is only allowed to use a, in comparison to built-in drivers, restricted \ac{api}\cite{glatz2015betriebssysteme}.
However, beeing a part of the kernel's address space brings drivers into a special responsibility.
There is no isolation between parts of the kernel, an errornous implemented driver may crash the entire system as a result.
For the implementation of a driver, the fact of it should be used as built-in driver or as module has just little impact.
It does require little or no changes on the source at all to switch between them as it is most of all a build configuration\cite{lfd430}.

Module driver are indeed useful, but not realizable for each device type.
Some drivers, e.g.\ disk drivers, must be present at a very early system stage to enable Linux to read from hard drives.
Writing such a disk driver as a module which needs to be read from a hard drive to be loaded into the system is not realizable accordingly\cite{quade2016Linux}.

\subsubsection*{Driver Interfaces}
As for device drivers in general need the ones in Linux functions to include themself into the system, i.e.\ methods to initialize respectively deinitialize the driver and the associated device, operating system triggered functions, e.g.\ interrupt handler functions, as well as user application tiggered routines to enable the communication between user and device\cite{quade2016Linux}.
The latter ones also include the driver-side implementations for the standard \ac{io} \ac{api}, the file operations.
It should be implemented in a device-specific way for the operations that are meaningful for the device.
If there is no such behaviour a device, it is preferred to implement only the meaningful operations, leave the default behaviour for the others one and switch to a better suited interface for the device.
Besides the standard \ac{io} \ac{api}, there are e.g.\ communication or multimedia specific \acp{api} which suits better to devices of these kinds.
Often, these interfaces are defined in Linux but built on basis of the \texttt{ioctl()} call which is technically a part of the file operationsi\cite{quade2016Linux}.
\ac{io} control is a universal interface to define own, device specific commands.
An \texttt{ioctl()} command is usually made from a made from a number and the type of optional arguments.
However, the preferred way is to utilize the macros Linux provide to define beside the number and the arument types also the size of the transfered data and their transfer direction\cite{quade2016Linux}.
This is the best way to verify \texttt{ioctl()} calls to a certain extent.
The calls defined for the use in \texttt{ioctl()}'s must be known in both, kernel and userspace.
Thus, this interface descriptions and corresponding datastructure definitions must be accessible from both sides.
Typically, they are found in \texttt{linux/include/uapi/linux/}\cite{quade2016Linux}.

To make the drivers implementations of these standard \ac{io} functions callable for the system and users, it is needed to declared them to the operating system kernel via specific calls.
They take structures with function pointers to the driver implementations as an argument.
Functions that do not have a meaning for a specific driver are denoted with a null pointer\cite{glatz2015betriebssysteme},\cite{quade2016Linux}.


\subsubsection*{Data Exchange}
Besides controlling the actual device is the communication with the user a main task of a driver and done as part of common calls like \texttt{read()}, \texttt{write()} or \texttt{ioctl()}.
This requires data exchange between processes.
\ac{ipc} was already a topic of this work, also the way it is done in Linux, but the communication between driver and user application is different.
It is not an exchange between processes in userspace but between kernel and userspace, with different address spaces, different virtual memory addresses types and different rights.
Addresses in the one address space are not neccessary meaningful in the other and additionally are user space buffers may swapped out from \ac{ram} to disk.
The Linux kernel helps in this situation with the built-in functions \texttt{copy\_from\_user()} and \texttt{copy\_to\_user()} which do the transition between the address spaces\cite{lfd430},~\cite{glatz2015betriebssysteme}.

Another way to exchange data between both worlds is the use of \textit{memory mapping} via the \texttt{mmap()} call, a standard \ac{posix} systemcall.
It enables user applications direct access to kernel memory buffers which may also include memory regions of a device controller, by mapping it into the application's address space.
Memory mapping affords a longer setup time than \texttt{copy\_to/from\_user()}, but once the mapping is ready, the access is faster and does not need further systemcalls\cite{lfd430},~\cite{glatz2015betriebssysteme}.
Normal files should never been accessed from kernelspace.
Thus, they are not suitable for data exchange between kernel and userspace\cite{lfd430}.

File operations are not the only option for an user interface to drivers.
Another one, the \textit{system filesystem (sysfs, /sys/)} is closely tied to the \textit{unified device model}.
It is a framework to handle all devices attached to a computer system in a unified scheme with similar data structures and functions.
The representation of this model in a running Linux system is the virtual sysfs.
It generated during runtime and spans a tree of devices with the system bus on its root as a system representation.
A driver's interaction with the model itself is most often limited.
It is only needed to register the driver on bus type the corresponding device is physically attached, like \ac{pci} or USB.
%TODO read corresponding to udev
Thus, the \textit{udev} mechanism is invoked.
It is a mechanism to create entries for devices in the \textit{/dev/} directory.
Without udev, it would be neccessary to create a corresponding node there manually using a device number consisting of a major number for the device type and a minor number to enumerate the device instance.
Drivers match on defined devices and it is rather a common situation than an exception one driver instance has to manage more than one fitting physical device.
The minor number is used to map exactly this situation without any mix-ups between the devices.
To comply, the driver implementation must also be designed to handle this purpose.
It must be \textit{reentrant}, i.e.\ one implementation must be able to handle a number of matching physical devices without mix-ups\cite{lfd430},~\cite{quade2016Linux}.

For drivers registered in the sysfs, this neccessary step there, the allocation of a correct device number, is done by udev using information exported there.
Besides the basically needed information which are exposed just by register the driver within sysfs is a driver allowed to expose further \textit{virtual files} underneath the devices node entry.
Those files provide an interface to the driver and can be made readable to expose information, writeable, e.g.\ to change device buffers or enter a defined command.
It is also possible to combine both operations or make the file not accessable at all.
The access permissions for a sysfs file entry are fine granular, based on \textit{group permissions}.
As the implementation for reading or writing of such a file with a freely selectable name is not further limited and a possible alternative to \textit{ioctl()}.
In contrast to \textit{ioctl()} calls, it is easier to access driver information via \textit{sysfs} as it only requires \textit{read()} or \textit{write()} calls and these can also be issued from a terminal\cite{lfd430},~\cite{quade2016Linux}.
%TODO verify with quade


\subsubsection*{Driver Lifecycle}

%TODO picture




\section{Zircon Driver Model}

\section{Test Setup}

\subsection{Hardware Issues}
% 1.8 vs 5V
%
% The RGB LCD has 2 chips with 2 different functionalities. One of it drives the LEDs and the other one drives the text that’s printed.
%
% The text driver is one and only and has an address of 0x3e.
%
% The LED driver has multiple addresses, of which we only need one. As it’s specified on page 8 (annex 7.1.1) in this datasheet (aka PCA9633) 9, there are 3 fixed addresses for our 8-pin chip package (the PCA9633):
%
% address 0x70 - LED all call address - it’s on at startup and cannot be addressed individually
%
% address 0x03 - Software reset address - it’s on at startup and cannot be addressed individually
%
% address 0x62 - Slave address - it’s the one you are communicating with and is addressable
%
% raspi pi@raspberrypi:~\$ i2cdetect -y 1
    % 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
% 00:          03 -- -- -- -- -- -- -- -- -- -- -- --
% 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- 3e --
% 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 60: -- -- 62 -- -- -- -- -- -- -- -- -- -- -- -- --
% 70: 70 -- -- -- -- -- -- --
%
%
% root@linaro-developer:~# i2cdetect -y -r 0
    % 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
% 00:          -- -- -- -- -- -- -- -- -- -- -- -- --
% 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
% 60: -- -- 62 -- -- -- -- -- -- -- -- -- -- -- -- --
% 70: 70 -- -- -- -- -- -- --
%
% https://www.kernel.org/doc/Documentation/i2c/instantiating-devices
% https://www.kernel.org/doc/Documentation/i2c/writing-clients
% https://raw.githubusercontent.com/torvalds/linux/v4.20/include/linux/i2c.h
% https://i2c.wiki.kernel.org/index.php/OF_Modalias



\section{General Driver Concept}\label{sec:cs-driver-concept}


\section{Linux}\label{sec:cs-linux}


\subsection{Driver Implementation} %TODO better titel, label
\subsubsection{Interface} %ioctl
    % Development setup for x86-64, ARM64, ...
